from django.db.models import Sum, Count, Avg, F, Q
from django.utils import timezone
from datetime import timedelta
from ..models import (
    Project, ProjectRevenueTransaction, ProjectStage, ConstructionStage,
    Worker, WorkerProject, ProjectWorkerRequirement, WorkerAssignment,
    LeadStatus
)
from .worker_service import calculate_worker_revenue, calculate_influence_score


# =====================================================
# REVENUE ANALYTICS
# =====================================================

def revenue_per_pincode():
    """Calculate total revenue grouped by pincode"""
    return ProjectRevenueTransaction.objects.values(
        "project__pincode"
    ).annotate(
        total_revenue=Sum("revenue_amount"),
        project_count=Count('project', distinct=True)
    ).order_by('-total_revenue')


def revenue_per_stage():
    """Calculate total revenue grouped by construction stage"""
    return ProjectRevenueTransaction.objects.values(
        "stage__name"
    ).annotate(
        total_revenue=Sum("revenue_amount"),
        transaction_count=Count('id')
    ).order_by('-total_revenue')


def revenue_per_worker():
    """Calculate revenue generated by each worker"""
    return ProjectRevenueTransaction.objects.values(
        "worker__id",
        "worker__name",
        "worker__worker_code"
    ).annotate(
        total_revenue=Sum("revenue_amount"),
        transaction_count=Count('id')
    ).order_by("-total_revenue")


def get_revenue_summary(days=30):
    """Get overall revenue summary"""
    from_date = timezone.now().date() - timedelta(days=days)
    
    total_revenue = ProjectRevenueTransaction.objects.aggregate(
        total=Sum('revenue_amount')
    )['total'] or 0
    
    recent_revenue = ProjectRevenueTransaction.objects.filter(
        transaction_date__gte=from_date
    ).aggregate(
        total=Sum('revenue_amount')
    )['total'] or 0
    
    total_margin = ProjectRevenueTransaction.objects.aggregate(
        total=Sum('margin_amount')
    )['total'] or 0
    
    avg_margin_percent = (total_margin / total_revenue * 100) if total_revenue > 0 else 0
    
    return {
        'total_revenue': total_revenue,
        'recent_revenue': recent_revenue,
        'total_margin': total_margin,
        'avg_margin_percent': round(avg_margin_percent, 2),
        'transaction_count': ProjectRevenueTransaction.objects.count(),
        'days': days
    }


# =====================================================
# PROJECT ANALYTICS
# =====================================================

def get_project_statistics():
    """Get overall project statistics"""
    total_projects = Project.objects.count()
    active_projects = Project.objects.filter(is_active=True).count()
    won_projects = Project.objects.filter(lead_status__is_won=True).count()
    lost_projects = Project.objects.filter(lead_status__is_lost=True).count()
    
    # Win rate
    final_projects = Project.objects.filter(lead_status__is_final=True).count()
    win_rate = (won_projects / final_projects * 100) if final_projects > 0 else 0
    
    return {
        'total_projects': total_projects,
        'active_projects': active_projects,
        'won_projects': won_projects,
        'lost_projects': lost_projects,
        'in_pipeline': total_projects - final_projects,
        'win_rate': round(win_rate, 1)
    }


def calculate_stage_dropoff():
    """
    Calculate stage drop-off rate (stages entered but not captured)
    Returns: List of stages with dropoff metrics
    """
    stages = ConstructionStage.objects.all().order_by('sequence_order')
    dropoff_data = []
    
    for stage in stages:
        # Projects that have this stage
        projects_entered = ProjectStage.objects.filter(
            stage=stage
        ).values('project').distinct().count()
        
        # Projects that captured revenue at this stage
        projects_captured = ProjectStage.objects.filter(
            stage=stage,
            captured_stage_revenue__gt=0
        ).values('project').distinct().count()
        
        # Projects that lost this stage
        projects_lost = projects_entered - projects_captured
        
        if projects_entered > 0:
            dropoff_rate = (projects_lost / projects_entered) * 100
        else:
            dropoff_rate = 0
        
        dropoff_data.append({
            'stage': stage,
            'stage_name': stage.name,
            'projects_entered': projects_entered,
            'projects_captured': projects_captured,
            'projects_lost': projects_lost,
            'dropoff_rate': round(dropoff_rate, 1)
        })
    
    return dropoff_data


def get_lead_conversion_funnel():
    """Get lead status conversion funnel"""
    statuses = LeadStatus.objects.all().order_by('sequence_order')
    
    funnel = []
    for status in statuses:
        count = Project.objects.filter(lead_status=status).count()
        funnel.append({
            'status': status,
            'status_name': status.name,
            'count': count
        })
    
    return funnel


# =====================================================
# WORKER ANALYTICS
# =====================================================

def perform_pareto_analysis():
    """
    Perform Pareto analysis (80/20 rule) on workers
    Identify top 20% workers generating 80% revenue
    """
    workers = Worker.objects.filter(active_status=True)
    
    worker_revenue = []
    for worker in workers:
        revenue = calculate_worker_revenue(worker)
        if revenue > 0:
            worker_revenue.append({
                'worker': worker,
                'revenue': revenue
            })
    
    if not worker_revenue:
        return {
            'top_workers': [],
            'count': 0,
            'percentage': 0,
            'revenue_generated': 0,
            'total_revenue': 0
        }
    
    # Sort by revenue DESC
    worker_revenue.sort(key=lambda x: x['revenue'], reverse=True)
    
    # Calculate cumulative revenue
    total_revenue = sum(wr['revenue'] for wr in worker_revenue)
    target_revenue = total_revenue * 0.80
    
    cumulative = 0
    top_workers = []
    
    for wr in worker_revenue:
        cumulative += wr['revenue']
        top_workers.append(wr)
        
        if cumulative >= target_revenue:
            break
    
    pareto_percentage = (len(top_workers) / len(worker_revenue)) * 100
    
    return {
        'top_workers': top_workers,
        'count': len(top_workers),
        'percentage': round(pareto_percentage, 1),
        'revenue_generated': cumulative,
        'total_revenue': total_revenue,
        'total_workers': len(worker_revenue)
    }


def get_top_workers_by_influence(limit=10):
    """Get top workers by influence score"""
    workers = Worker.objects.filter(active_status=True)
    
    worker_scores = []
    for worker in workers:
        influence = calculate_influence_score(worker)
        revenue = calculate_worker_revenue(worker)
        worker_scores.append({
            'worker': worker,
            'influence_score': influence,
            'revenue': revenue,
            'projects_count': worker.worker_projects.count()
        })
    
    # Sort by influence score
    worker_scores.sort(key=lambda x: x['influence_score'], reverse=True)
    
    return worker_scores[:limit]


def analyze_worker_assignment_impact():
    """
    Analyze impact of worker assignments on project win rate
    Compare projects with vs without worker assignments
    """
    # Get all projects with final status
    projects = Project.objects.filter(
        lead_status__is_final=True
    )
    
    # Segment 1: Projects WITH worker assignments
    projects_with_workers = projects.filter(
        worker_requirements__assignment__isnull=False
    ).distinct()
    
    won_with_workers = projects_with_workers.filter(
        lead_status__is_won=True
    ).count()
    
    total_with_workers = projects_with_workers.count()
    
    # Segment 2: Projects WITHOUT worker assignments
    projects_without_workers = projects.exclude(
        id__in=projects_with_workers.values_list('id', flat=True)
    )
    
    won_without_workers = projects_without_workers.filter(
        lead_status__is_won=True
    ).count()
    
    total_without_workers = projects_without_workers.count()
    
    # Calculate win rates
    win_rate_with_workers = (
        (won_with_workers / total_with_workers * 100) 
        if total_with_workers > 0 else 0
    )
    
    win_rate_without_workers = (
        (won_without_workers / total_without_workers * 100) 
        if total_without_workers > 0 else 0
    )
    
    impact = win_rate_with_workers - win_rate_without_workers
    
    return {
        'with_workers': {
            'total': total_with_workers,
            'won': won_with_workers,
            'win_rate': round(win_rate_with_workers, 1)
        },
        'without_workers': {
            'total': total_without_workers,
            'won': won_without_workers,
            'win_rate': round(win_rate_without_workers, 1)
        },
        'impact': round(impact, 1),
        'impact_positive': impact > 0
    }


# =====================================================
# PINCODE ANALYTICS
# =====================================================

def get_pincode_heatmap_data():
    """Get comprehensive pincode analytics for heatmap"""
    # Revenue per pincode
    revenue_data = revenue_per_pincode()
    
    # Worker count per pincode
    worker_count = Worker.objects.filter(
        active_status=True
    ).values('primary_pincode').annotate(
        count=Count('id')
    )
    
    # Project count per pincode
    project_count = Project.objects.filter(
        is_active=True
    ).values('pincode').annotate(
        count=Count('id')
    )
    
    # Combine data
    pincode_data = {}
    
    for item in revenue_data:
        pincode = item['project__pincode']
        pincode_data[pincode] = {
            'pincode': pincode,
            'revenue': item['total_revenue'],
            'projects': item['project_count'],
            'workers': 0
        }
    
    for item in worker_count:
        pincode = item['primary_pincode']
        if pincode in pincode_data:
            pincode_data[pincode]['workers'] = item['count']
    
    return list(pincode_data.values())


# =====================================================
# DASHBOARD SUMMARY
# =====================================================

def get_dashboard_summary():
    """Get comprehensive dashboard summary with all KPIs"""
    return {
        'revenue': get_revenue_summary(30),
        'projects': get_project_statistics(),
        'pareto': perform_pareto_analysis(),
        'assignment_impact': analyze_worker_assignment_impact(),
        'recent_transactions': ProjectRevenueTransaction.objects.select_related(
            'project', 'stage', 'worker'
        ).order_by('-transaction_date')[:10]
    }
