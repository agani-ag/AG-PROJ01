from django.db.models import Sum, Count, F, Q
from django.utils import timezone
from datetime import timedelta, date
from ..models import (
    Worker, ProjectRevenueTransaction, Project, 
    WorkerProject, WorkerAssignment, WorkerCreditLedger
)

# =====================================================
# WORKER REVENUE & BASIC METRICS
# =====================================================

def calculate_worker_revenue(worker):
    """Calculate total revenue generated by worker"""
    result = ProjectRevenueTransaction.objects.filter(
        worker=worker
    ).aggregate(total=Sum("revenue_amount"))
    return result["total"] or 0


# =====================================================
# WORKER SCORING SYSTEM
# =====================================================

def calculate_influence_score(worker):
    """
    Calculate worker's overall business impact and network value
    Score: 0-100
    Components: Project Referrals (40%) + Revenue (30%) + Network (20%) + Tenure (10%)
    """
    # Component 1: Project Referral Score (40%)
    projects_referred = Project.objects.filter(referred_by_worker=worker).count()
    project_referral_score = min(projects_referred * 10, 100)
    
    # Component 2: Revenue Generation Score (30%)
    total_revenue = calculate_worker_revenue(worker)
    revenue_generation_score = min(total_revenue / 10000, 100)
    
    # Component 3: Network Expansion Score (20%)
    network_size = WorkerProject.objects.filter(
        referred_by_worker=worker
    ).values('worker').distinct().count()
    network_expansion_score = min(network_size * 5, 100)
    
    # Component 4: Tenure Score (10%)
    days_active = (date.today() - worker.joined_date).days
    months_active = days_active / 30
    tenure_score = min(months_active * 2, 100)
    
    # Final weighted score
    influence_score = (
        project_referral_score * 0.40 +
        revenue_generation_score * 0.30 +
        network_expansion_score * 0.20 +
        tenure_score * 0.10
    )
    
    return round(influence_score, 2)


def calculate_loyalty_score(worker):
    """
    Calculate worker's commitment and referral activity
    Score: 0-100
    Enhanced with recency and frequency factors
    """
    total_projects_worked = worker.worker_projects.count()
    projects_referred = Project.objects.filter(referred_by_worker=worker).count()
    
    if total_projects_worked == 0:
        return 0
    
    # Component 1: Referral Ratio (50%)
    referral_ratio = (projects_referred / total_projects_worked) * 50
    
    # Component 2: Recent Activity (30%)
    recent_referrals = Project.objects.filter(
        referred_by_worker=worker,
        created_at__gte=timezone.now() - timedelta(days=180)
    ).count()
    recency_score = min(recent_referrals * 10, 30)
    
    # Component 3: Referral Frequency (20%)
    days_active = (date.today() - worker.joined_date).days
    months_active = max(days_active / 30, 1)
    referral_frequency = projects_referred / months_active
    frequency_score = min(referral_frequency * 10, 20)
    
    loyalty_score = referral_ratio + recency_score + frequency_score
    
    return round(min(loyalty_score, 100), 2)


def calculate_reliability_score(worker):
    """
    Assess payment reliability and credit risk
    Score: 0-100 (Higher = More Reliable)
    Based on credit ledger history
    """
    ledger_entries = WorkerCreditLedger.objects.filter(worker=worker)
    
    total_transactions = ledger_entries.count()
    if total_transactions == 0:
        return 100  # New worker, no history = neutral/good
    
    # Calculate settlement metrics
    settled_on_time = ledger_entries.filter(
        is_settled=True
    ).count()
    
    overdue_count = ledger_entries.filter(
        is_settled=False,
        due_date__lt=timezone.now().date()
    ).exclude(due_date__isnull=True).count()
    
    # Payment consistency
    payment_consistency = (settled_on_time / total_transactions) * 100
    
    # Penalty for overdue
    overdue_penalty = min(overdue_count * 15, 50)
    
    # Current balance factor
    latest_entry = ledger_entries.order_by('-id').first()
    current_balance = latest_entry.running_balance if latest_entry else 0
    
    if current_balance < -50000:
        balance_penalty = 30
    elif current_balance < -20000:
        balance_penalty = 15
    else:
        balance_penalty = 0
    
    reliability_score = max(
        payment_consistency - overdue_penalty - balance_penalty,
        0
    )
    
    return round(reliability_score, 2)


def calculate_availability_score(worker):
    """
    Determine if worker is available for new assignments
    Score: 0-100 (Higher = More Available)
    Each active assignment reduces availability by 25 points
    """
    active_assignments = WorkerAssignment.objects.filter(
        worker=worker,
        completion_date__isnull=True
    ).count()
    
    base_score = 100 - (active_assignments * 25)
    availability_score = max(base_score, 0)
    
    return round(availability_score, 2)


def get_availability_status(availability_score):
    """Convert availability score to status label"""
    if availability_score >= 75:
        return "AVAILABLE"
    elif availability_score >= 50:
        return "LIMITED"
    elif availability_score >= 25:
        return "BUSY"
    else:
        return "OVERLOADED"


# =====================================================
# WORKER PERFORMANCE ANALYTICS
# =====================================================

def get_worker_performance_summary(worker):
    """Get comprehensive performance summary for a worker"""
    return {
        'worker': worker,
        'total_revenue': calculate_worker_revenue(worker),
        'influence_score': calculate_influence_score(worker),
        'loyalty_score': calculate_loyalty_score(worker),
        'reliability_score': calculate_reliability_score(worker),
        'availability_score': calculate_availability_score(worker),
        'availability_status': get_availability_status(calculate_availability_score(worker)),
        'projects_count': worker.worker_projects.count(),
        'projects_referred': Project.objects.filter(referred_by_worker=worker).count(),
        'active_assignments': WorkerAssignment.objects.filter(
            worker=worker,
            completion_date__isnull=True
        ).count(),
    }


def get_top_performers(limit=10):
    """Get top performing workers by influence score"""
    workers = Worker.objects.filter(active_status=True)
    
    worker_scores = []
    for worker in workers:
        influence = calculate_influence_score(worker)
        revenue = calculate_worker_revenue(worker)
        worker_scores.append({
            'worker': worker,
            'influence_score': influence,
            'revenue': revenue
        })
    
    # Sort by influence score
    worker_scores.sort(key=lambda x: x['influence_score'], reverse=True)
    
    return worker_scores[:limit]


def get_workers_by_pincode(pincode, role=None):
    """Get workers in a specific pincode, optionally filtered by role"""
    query = Worker.objects.filter(
        primary_pincode=pincode,
        active_status=True
    )
    
    if role:
        query = query.filter(role=role)
    
    return query.select_related('role')


# =====================================================
# NETWORK ANALYTICS
# =====================================================

def calculate_collaboration_strength(worker_a, worker_b):
    """
    Calculate how well two workers collaborate
    Score: 0-100
    Based on: Projects together + Joint revenue
    """
    # Get projects both worked on
    projects_a = set(WorkerProject.objects.filter(
        worker=worker_a
    ).values_list('project_id', flat=True))
    
    projects_b = set(WorkerProject.objects.filter(
        worker=worker_b
    ).values_list('project_id', flat=True))
    
    common_projects = projects_a.intersection(projects_b)
    projects_together = len(common_projects)
    
    if projects_together == 0:
        return 0
    
    # Get revenue from those projects
    joint_revenue = ProjectRevenueTransaction.objects.filter(
        project_id__in=common_projects
    ).aggregate(total=Sum('revenue_amount'))['total'] or 0
    
    # Strength = frequency + success
    collaboration_strength = (
        min(projects_together * 15, 60) +
        min(joint_revenue / 10000, 40)
    )
    
    return round(min(collaboration_strength, 100), 2)


def get_worker_network_stats(worker):
    """Get network statistics for a worker"""
    return {
        'worker': worker,
        'projects_referred': Project.objects.filter(referred_by_worker=worker).count(),
        'workers_collaborated_with': WorkerProject.objects.filter(
            project_id__in=worker.worker_projects.values_list('project_id', flat=True)
        ).exclude(worker=worker).values('worker').distinct().count(),
        'network_brought_in': WorkerProject.objects.filter(
            referred_by_worker=worker
        ).values('worker').distinct().count(),
    }
